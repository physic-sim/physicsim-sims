"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkphysicsim"] = self["webpackChunkphysicsim"] || []).push([["src_Simulations_SnellsLawSimulation_SnellsLawSimulation_js"],{

/***/ "./src/Input/SliderInput.js":
/*!**********************************!*\
  !*** ./src/Input/SliderInput.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SliderInput: () => (/* binding */ SliderInput)\n/* harmony export */ });\nclass SliderInput {\n    base;\n    input;\n    min;\n    max;\n    label;\n    unit;\n    pLabel;\n\n    constructor(base, val, min, max, step, label, unit, update = true) {\n        this.base = base;\n        this.min = min;\n        this.max = max;\n        this.label = label;\n        this.unit = unit;\n\n        let container = document.createElement('div');\n        container.classList.add('slider-input-container');\n\n        this.pLabel = document.createElement('p');\n        if (update) {\n            this.pLabel.innerHTML = `${this.label} = ${val.toFixed(2)} ${this.unit}`;\n        } else {\n            this.pLabel.innerHTML = this.label;\n        }\n\n        this.input = document.createElement('input');\n        this.input.type = 'range';\n        this.input.min = this.min;\n        this.input.max = this.max;\n        this.input.value = val;\n        this.input.step = step;\n        this.input.classList.add('slider-input-slider');\n\n        container.append(this.pLabel, this.input);\n\n        this.base.append(container);\n\n        if (update) {\n            this.input.addEventListener('input', this.update.bind(this));\n        }\n    }\n\n    get() {\n        return parseFloat(this.input.value);\n    }\n\n    set(val) {\n        this.input.value = val;\n    }\n\n    update() {\n        this.pLabel.innerHTML = `${this.label} = ${this.get().toFixed(2)} ${this.unit}`;\n    }\n}\n\n\n//# sourceURL=webpack://physicsim/./src/Input/SliderInput.js?");

/***/ }),

/***/ "./src/Simulations/SnellsLawSimulation/BoxGeometry.js":
/*!************************************************************!*\
  !*** ./src/Simulations/SnellsLawSimulation/BoxGeometry.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BoxGeometry: () => (/* binding */ BoxGeometry)\n/* harmony export */ });\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p5 */ \"./node_modules/p5/lib/p5.min-exposed.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_0__);\n\n\nclass BoxGeometry {\n    constructor(w, h, d, c, n) {\n        this.w = w;\n        this.h = h;\n        this.d = d;\n        this.c = c;\n        this.n = n;\n        // normal vectors\n        this.normals = [\n            new (p5__WEBPACK_IMPORTED_MODULE_0___default().Vector)(0, 0, -1),\n            new (p5__WEBPACK_IMPORTED_MODULE_0___default().Vector)(0, 0, 1),\n            new (p5__WEBPACK_IMPORTED_MODULE_0___default().Vector)(0, -1, 0),\n            new (p5__WEBPACK_IMPORTED_MODULE_0___default().Vector)(0, 1, 0),\n            new (p5__WEBPACK_IMPORTED_MODULE_0___default().Vector)(-1, 0, 0),\n            new (p5__WEBPACK_IMPORTED_MODULE_0___default().Vector)(1, 0, 0),\n        ];\n        // compute planes\n        this.planes = [];\n\n        for (let i = 0; i < this.normals.length; i++) {\n            let n = this.normals[i];\n\n            // compute position vector\n            let r;\n            if (i < 2) {\n                r = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(n, this.d / 2);\n            } else if (i > 3) {\n                r = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(n, this.w / 2);\n            } else {\n                r = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(n, this.h / 2);\n            }\n\n            let p = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.add(this.c, r);\n\n            this.planes.push([p, n]);\n        }\n    }\n\n    show(p) {\n        // draw box geometry\n        p.push();\n        p.translate(this.c);\n        p.stroke(255, 255, 255, 200);\n        p.fill(0, 200, 255, 100);\n        p.box(this.w, this.h, this.d, 4, 4);\n        p.pop();\n    }\n\n    isInside(point, UNCERTAINTY) {\n        // check if point lies on the surface or inside the geometry\n        if (\n            point.x >= this.c.x - this.w / 2 - UNCERTAINTY &&\n            point.x <= this.c.x + this.w / 2 + UNCERTAINTY &&\n            point.y >= this.c.y - this.h / 2 - UNCERTAINTY &&\n            point.y <= this.c.y + this.h / 2 + UNCERTAINTY &&\n            point.z >= this.c.z - this.d / 2 - UNCERTAINTY &&\n            point.z <= this.c.z + this.d / 2 + UNCERTAINTY\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n\n//# sourceURL=webpack://physicsim/./src/Simulations/SnellsLawSimulation/BoxGeometry.js?");

/***/ }),

/***/ "./src/Simulations/SnellsLawSimulation/Ray.js":
/*!****************************************************!*\
  !*** ./src/Simulations/SnellsLawSimulation/Ray.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ray: () => (/* binding */ Ray)\n/* harmony export */ });\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p5 */ \"./node_modules/p5/lib/p5.min-exposed.js\");\n/* harmony import */ var p5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(p5__WEBPACK_IMPORTED_MODULE_0__);\n\n\nclass Ray {\n    constructor(src, dir, n, isSource, maxDepth) {\n        this.src = src;\n        this.dir = dir.normalize();\n        this.n = n;\n        this.isSource = isSource;\n        this.maxDepth = maxDepth;\n        this.next = null;\n        this.data = [];\n    }\n\n    draw(scene, p, UNCERTAINTY, depth) {\n        if (depth >= this.maxDepth) {\n            return;\n        }\n\n        if (this.isSource) {\n            p.push();\n            p.translate(this.src);\n            p.fill(255, 255, 0);\n            p.noStroke();\n            p.sphere(1, 24, 24);\n            p.pop();\n        }\n\n        // check for intersection with geometry to find first plane which is interacted width\n        let dist = Infinity;\n        let intersection = null;\n        let geometry = null;\n        let plane = null;\n\n        for (let i = 0; i < scene.length; i++) {\n            let geo = scene[i];\n\n            // check for intersection with each plane\n            for (let j = 0; j < geo.planes.length; j++) {\n                let pln = geo.planes[j];\n\n                let m = pln[0];\n                let n = pln[1];\n\n                if (!(p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.dot(this.src, m) == 0)) {\n                    let pTakeSrc = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.sub(m, this.src);\n                    let pTakeSrcDotN = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.dot(n, pTakeSrc);\n                    let nDotDir = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.dot(this.dir, n);\n                    let t = pTakeSrcDotN / nDotDir;\n\n                    if (Math.abs(t) == Infinity) {\n                        continue;\n                    }\n\n                    let tDir = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(this.dir, t);\n\n                    // Check if the calculated point lies on the plane\n                    let x = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.add(this.src, tDir);\n\n                    // Check if point lies in the cube and is shortest distance\n                    if (\n                        geo.isInside(x, UNCERTAINTY) &&\n                        t > UNCERTAINTY &&\n                        t < dist\n                    ) {\n                        dist = t;\n                        intersection = x;\n                        plane = pln;\n                        geometry = geo;\n                    }\n                }\n            }\n        }\n\n        if (intersection) {\n            // draw ray\n            p.push();\n            p.stroke(255, 255, 0, 255);\n            p.strokeWeight(1);\n            p.line(\n                this.src.x,\n                this.src.y,\n                this.src.z,\n                intersection.x,\n                intersection.y,\n                intersection.z\n            );\n            p.pop();\n\n            // draw normal at point\n            p.push();\n            p.translate(intersection);\n            p.stroke(255, 255, 255, 240);\n            p.line(\n                plane[1].x * -7.5,\n                plane[1].y * -7.5,\n                plane[1].z * -7.5,\n                plane[1].x * 7.5,\n                plane[1].y * 7.5,\n                plane[1].z * 7.5\n            );\n            p.pop();\n\n            // calculate new vector after\n            let n1 = this.n;\n            let n2;\n            let n;\n\n            // check if ray is already inside the geometry\n            if (geometry.isInside(this.src, UNCERTAINTY)) {\n                n1 = geometry.n;\n                n2 = 1;\n                n = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(plane[1], -1);\n            } else {\n                n2 = geometry.n;\n                n = plane[1];\n            }\n\n            // Check for TIR\n            let cosc = Math.sqrt(1 - Math.pow(n2 / n1, 2));\n            let c = p.acos(cosc);\n\n            let negativeN = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(n, -1);\n            let cosi = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.dot(negativeN, this.dir);\n            let i = p.acos(cosi);\n\n            // log interactions\n            this.data = [i, '', '', n1, n2];\n\n            if (n2 / n1 < 1) {\n                this.data[1] = c;\n            }\n\n            let ref;\n\n            if (i > c && n2 / n1 < 1) {\n                // total internal reflection\n                let cosN = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(n, 2 * cosi);\n                n2 = n1;\n                ref = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.add(this.dir, cosN);\n            } else {\n                let cosr = Math.sqrt(\n                    1 - Math.pow(n1 / n2, 2) * (1 - Math.pow(cosi, 2))\n                );\n                let nMultL = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(this.dir, n1 / n2);\n                let angMultN = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.mult(n, (n1 / n2) * cosi - cosr);\n\n                ref = p5__WEBPACK_IMPORTED_MODULE_0___default().Vector.add(nMultL, angMultN);\n\n                this.data[2] = p.acos(cosr);\n            }\n\n            this.next = new Ray(intersection, ref, n2, false, this.maxDepth);\n            this.next.draw(scene, p, UNCERTAINTY, (depth += 1));\n        } else {\n            p.push();\n            p.translate(this.src);\n            p.stroke(255, 255, 0, 255);\n            p.strokeWeight(1);\n            p.line(0, 0, 0, this.dir.x * 50, this.dir.y * 50, this.dir.z * 50);\n            p.pop();\n        }\n    }\n}\n\n\n//# sourceURL=webpack://physicsim/./src/Simulations/SnellsLawSimulation/Ray.js?");

/***/ }),

/***/ "./src/Simulations/SnellsLawSimulation/SnellsLawSimulation.js":
/*!********************************************************************!*\
  !*** ./src/Simulations/SnellsLawSimulation/SnellsLawSimulation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SnellsLawSimulation)\n/* harmony export */ });\n/* harmony import */ var _ThreeDSimulation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ThreeDSimulation */ \"./src/Simulations/ThreeDSimulation.js\");\n/* harmony import */ var _Controls_Button__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Controls/Button */ \"./src/Controls/Button.js\");\n/* harmony import */ var _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Input/SliderInput */ \"./src/Input/SliderInput.js\");\n/* harmony import */ var _Ray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Ray */ \"./src/Simulations/SnellsLawSimulation/Ray.js\");\n/* harmony import */ var _BoxGeometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BoxGeometry */ \"./src/Simulations/SnellsLawSimulation/BoxGeometry.js\");\n\n\n\n\n\n\nclass SnellsLawSimulation extends _ThreeDSimulation__WEBPACK_IMPORTED_MODULE_0__.ThreeDSimulation {\n    UNCERTAINTY = 1e-6;\n\n    constructor(container, inputs, graphs, controls, attributes) {\n        super(container, inputs, graphs, controls, attributes, true);\n\n        // add inputs\n        this.posXInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            -25,\n            -75,\n            75,\n            0.1,\n            'pos<sub>x</sub>',\n            ''\n        );\n\n        this.posYInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            0,\n            -75,\n            75,\n            0.1,\n            'pos<sub>y</sub>',\n            ''\n        );\n\n        this.posZInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            25,\n            -75,\n            75,\n            0.1,\n            'pos<sub>z</sub>',\n            ''\n        );\n\n        this.dirXInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            3,\n            -5,\n            5,\n            0.1,\n            'dir<sub>x</sub>',\n            ''\n        );\n\n        this.dirYInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            0,\n            -5,\n            5,\n            0.1,\n            'dir<sub>y</sub>',\n            ''\n        );\n\n        this.dirZInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            -3,\n            -5,\n            5,\n            0.1,\n            'dir<sub>z</sub>',\n            ''\n        );\n\n        this.nInput = new _Input_SliderInput__WEBPACK_IMPORTED_MODULE_2__.SliderInput(\n            this.inputWrapper,\n            1,\n            0,\n            5.0,\n            0.01,\n            'Refractive Index',\n            ''\n        );\n\n        // init data\n        this.interactions = [];\n    }\n\n    init(p) {\n        // alter WEBGL\n        let gl = p._renderer.GL;\n        p._renderer.GL.enable(gl.BLEND);\n        p._renderer.GL.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n        // add custom btns\n        this.downloadBtn = new _Controls_Button__WEBPACK_IMPORTED_MODULE_1__.Button(\n            this.controlWrapper,\n            this.download.bind(this),\n            'Data',\n        );\n\n        // load values from ui\n        let posX = this.posXInput.get();\n        let posY = this.posZInput.get();\n        let posZ = this.posYInput.get();\n\n        let dirX = this.dirXInput.get();\n        let dirY = this.dirZInput.get();\n        let dirZ = this.dirYInput.get();\n\n        // init ray & geometry\n        this.scene = [];\n        this.ray = new _Ray__WEBPACK_IMPORTED_MODULE_3__.Ray(\n            p.createVector(posX, -posY, posZ),\n            p.createVector(dirX, -dirY, dirZ),\n            1,\n            true,\n            10,\n        );\n        this.scene.push(\n            new _BoxGeometry__WEBPACK_IMPORTED_MODULE_4__.BoxGeometry(\n                75,\n                15,\n                40,\n                p.createVector(0, 0, 0),\n                this.nInput.get(),\n            )\n        );\n    }\n\n    frame(p) {\n        if (this.rotateControl) {\n            p.orbitControl();\n        }\n\n        p.ambientLight(255);\n        p.perspective(0.2, this.width / this.height, 10, 500000);\n\n        // load values from ui\n        let posX = this.posXInput.get();\n        let posY = this.posZInput.get();\n        let posZ = this.posYInput.get();\n\n        let dirX = this.dirXInput.get();\n        let dirY = this.dirZInput.get();\n        let dirZ = this.dirYInput.get();\n\n        let n = this.nInput.get();\n\n        this.scene[0].n = n;\n\n        // prevent point from going into geometry\n        let isInGeometry = false;\n\n        for (let i = 0; i < this.scene.length; i++) {\n            if (\n                this.scene[i].isInside(\n                    p.createVector(posX, -posY, posZ),\n                    this.UNCERTAINTY,\n                )\n            ) {\n                isInGeometry = true;\n            }\n        }\n\n        if (!isInGeometry) {\n            this.ray.src.x = posX;\n            this.ray.src.y = -posY;\n            this.ray.src.z = posZ;\n        }\n\n        this.ray.dir.x = dirX;\n        this.ray.dir.y = -dirY;\n        this.ray.dir.z = dirZ;\n\n        this.ray.dir.normalize();\n\n        this.ray.draw(this.scene, p, this.UNCERTAINTY, 0);\n\n        for (let i = 0; i < this.scene.length; i++) {\n            this.scene[i].n = n;\n            this.scene[i].show(p);\n        }\n\n        // render table of interactions\n        if (this.selected == 'graphs') {\n            this.interactions = [];\n            let next = this.ray;\n\n            while (next !== null) {\n                this.interactions.push(next.data);\n                next = next.next;\n            }\n\n            this.tabulate(this.interactions);\n        }\n    }\n\n    tabulate(interactions) {\n        this.graphWrapper.innerHTML = '';\n        this.graphWrapper.style.display = 'block';\n\n        // title table\n        let title = document.createElement('h2');\n        title.innerHTML = 'Surface Interactions';\n        title.classList.add('table-title');\n        this.graphWrapper.append(title);\n\n        // table wrapper\n        let table = document.createElement('table');\n        table.classList.add('table-wrapper');\n\n        // add header\n        let head = document.createElement('thead');\n        head.classList.add('table-head');\n        let headTr = document.createElement('tr');\n        let iHead = document.createElement('th');\n        iHead.innerHTML = 'i/°';\n        iHead.scope = 'col';\n        iHead.className = 'table-td';\n        let cHead = document.createElement('th');\n        cHead.innerHTML = 'c/°';\n        cHead.scope = 'col';\n        cHead.className = 'table-td';\n        let rHead = document.createElement('th');\n        rHead.innerHTML = 'r/°';\n        rHead.scope = 'col';\n        rHead.className = 'table-td';\n        let n1Head = document.createElement('th');\n        n1Head.innerHTML = 'n1';\n        n1Head.scope = 'col';\n        n1Head.className = 'table-td';\n        let n2Head = document.createElement('th');\n        n2Head.innerHTML = 'n2';\n        n2Head.scope = 'col';\n        n2Head.className = 'table-td';\n        headTr.append(iHead, cHead, rHead, n1Head, n2Head);\n        head.append(headTr);\n        table.append(head);\n        // add data\n        let body = document.createElement('tbody');\n        body.classList.add('table-body');\n        interactions.map((data, index) => {\n            // show interaction\n            let tr = document.createElement('tr');\n            tr.classList.add('table-tr');\n\n            for (let i = 0; i < data.length; i++) {\n                let d = data[i];\n                let td = document.createElement('td');\n                td.classList.add('table-td');\n\n                if (d == '') {\n                    td.innerHTML = d;\n                } else if (i < 3) {\n                    td.innerHTML = (d * (180 / Math.PI)).toFixed(2);\n                } else {\n                    td.innerHTML = d.toFixed(2);\n                }\n\n                tr.appendChild(td);\n            }\n\n            body.appendChild(tr);\n        });\n\n        table.appendChild(body);\n        this.graphWrapper.append(table);\n    }\n\n    download() {\n        let data = this.interactions;\n        let headers = 'i/rad, c/rad, r/rad, n1, n2\\n';\n        let strData = data.map((row) => row.join(',')).join('\\n');\n        let csvData = headers.concat(strData);\n        let blob = new Blob([csvData], { type: 'text/csv' });\n        let url = window.URL.createObjectURL(blob);\n\n        let a = document.createElement('a');\n        a.setAttribute('hidden', '');\n        a.setAttribute('href', url);\n        a.setAttribute('download', 'data.csv');\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n    }\n}\n\n/*\n\nlet ray;\nlet scene = []\nlet interactions = []\n\nconst UNCERTAINTY = 1e-6\n\nfunction setup() {\n  let viewWidth;\n  let viewHeight;\n\n  if (window.innerWidth < 800) {\n    viewWidth = window.innerWidth * 0.9\n    viewHeight = window.innerHeight * 0.75;\n  } else {\n    viewWidth = window.innerWidth * 0.75\n    viewHeight = document.getElementById('ctrl').offsetHeight;\n  }\n\n  if (viewHeight < window.innerHeight * 0.75) {\n    viewHeight = window.innerHeight * 0.75\n  }\n\n  createCanvas(viewWidth, viewHeight, WEBGL, document.getElementById('sketch'));\n  gl = this._renderer.GL;\n  gl.enable(gl.BLEND);\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);   \n  ray = new Ray(createVector(0, 0, 0), createVector(50, 15, 0), 1, true);\n  scene.push(new BoxGeometry(75, 15, 40, createVector(0, 0, 0), 1.5));}\n\nfunction draw() {\n  // disable loading screen on first draw\n  pageLoaded()\n\n  background(0);\n  ambientLight(255);\n  perspective(0.2, (width / height), 10, 500000)\n  orbitControl()\n\n  // clear data\n  document.getElementById('table-data').innerHTML = '';\n  interactions = [];\n  \n  // load values from ui\n  let posX = parseFloat(document.getElementById('posX').value);\n  let posY = parseFloat(document.getElementById('posY').value);\n  let posZ = parseFloat(document.getElementById('posZ').value);\n\n  let dirX = parseFloat(document.getElementById('dirX').value);\n  let dirY = parseFloat(document.getElementById('dirY').value);\n  let dirZ = parseFloat(document.getElementById('dirZ').value);\n\n  let n = parseFloat(document.getElementById('n').value);\n\n  // prevent point from going into geometry\n  let isInGeometry = false;\n\n  for (let i = 0; i < scene.length; i++) {\n    if (scene[i].isInside(createVector(posX, -posY, posZ))) {\n      isInGeometry = true;\n    }\n  }\n  \n  if (!isInGeometry) {\n    ray.src.x = posX;\n    ray.src.y = -posY;\n    ray.src.z = posZ;\n  }\n\n  ray.dir.x = dirX;\n  ray.dir.y = -dirY;\n  ray.dir.z = dirZ;\n\n  ray.dir.normalize();\n  \n  ray.draw(scene)\n  \n  for (let i = 0; i < scene.length; i++) {\n    scene[i].n = n;\n    scene[i].show();\n  }\n}\n\ndocument.getElementById('download').addEventListener('click', () => {\n  let data = interactions;\n  let headers = 'i/rad, c/rad, r/rad, n1, n2\\n'\n  let strData = data.map(row => row.join(\",\")).join(\"\\n\");\n  let csvData = headers.concat(strData);\n  let blob = new Blob([csvData], { type: 'text/csv' });\n  let url = window.URL.createObjectURL(blob);\n\n  let a = document.createElement('a')\n  a.setAttribute('hidden', '');\n  a.setAttribute('href', url);\n  a.setAttribute('download', 'data.csv');\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n})\n\n*/\n\n\n//# sourceURL=webpack://physicsim/./src/Simulations/SnellsLawSimulation/SnellsLawSimulation.js?");

/***/ })

}]);